A) Backend Prompt List (Claude Code) //done
0. Pre-requisites & Repo Bootstrap

Prompt to Claude Code:
Prepare workstation (Node LTS, pnpm/npm, Git; VSCode: Solidity/ESLint/Prettier). Initialize repo:

/contracts /scripts /test /tools /docs
.editorconfig .gitignore package.json


Init Hardhat (TS), add OpenZeppelin, dotenv, merkletreejs. Create docs/summary.md (rolling log) and docs/architecture.md (skeleton). Output commands to install/verify.

Success: compiles empty project, docs created, scripts present.
Update summary.md: “Repo & tooling initialized; next: contract scaffolding.”

1. Contract Scaffolding //done

Create contracts/Election.sol + contracts/BalToken.sol with storage, events, admin setters; stub modifiers (onlyWhitelisted, onlyDuringElection), no voting yet. BAL is ERC20; minter will be Election.

Success: clean compile; storage/events ready.
Update summary.md: “Scaffolded contracts; next: voting + reward + quiz.”

2. Voting + Merkle + Rewards + Quiz //done

Implement:

voteDirect(candidateId, proof) with Merkle verification, one-vote rule, reentrancy guard, BAL mint on success.

voteByQuiz([3]uint8 answers, proof) compute L1 distance to candidate topics; record vote; mint BAL; do not reveal chosen candidate to caller.

finalizeIfEnded(); getCandidates(); simple ranking helper or UI-sorted results.

Success: compiles; functions implemented; events emitted; guards enforced.
Update summary.md: “Core voting done; next: tests.”

3. Tests (TypeScript, Hardhat) //done

Write comprehensive tests: add candidates; times; whitelist pass/fail; single-vote; reward mint; quiz path; window closed; ownership. Include a Merkle builder helper for fixtures.

Success: tests pass with coverage for happy/edge paths.
Update summary.md: “Tests green; next: tools.”

4. Tools — Merkle Builder

Create /tools CLI:

Input: tools/voters.csv (one address per line/header).

Output: tools/out/merkle.json → {root, leaves, proofs[address]}.
Validate, dedupe, checksum; script alias merkle:build.

Success: produces root & proofs reliably.
Update summary.md: “Merkle CLI ready; next: deploy.”

5. Deployment Scripts

Hardhat scripts + .env: deploy BalToken, then Election; grant minter; set reward, root, and times; save to deployments/<network>.json for local & Sepolia.

Success: deployment JSONs created; wiring correct.
Update summary.md: “Deploy scripts done; next: architecture doc, then FE.”

6. Architecture Doc

Fill docs/architecture.md: components, contract APIs, data flows (ASCII sequences), Merkle flow, time window, quiz math, security notes, known issues.

Success: doc complete and consistent.
Update summary.md: “Architecture documented; next: frontend.”

7. Security/Gas Pass

Tighten input checks, access control, NatSpec, event completeness, struct packing, order of effects → interactions, timestamp usage. Add SECURITY.md.

Success: diffs improving safety; SECURITY.md added.
Update summary.md: “Security pass complete.”

8. Wrap-Up (Backend README block)

Prepare the backend parts for the final README.md: install, test, tool usage, deploy steps, troubleshooting (env, chains, proofs).

Success: backend sections ready to be merged in final README.
Update summary.md: “Backend docs staged; hand-off to FE.”

Final Wrap-Up Prompt (Claude Code)

Have Claude generate the final README.md by merging the backend/FE blocks, plus E2E demo steps (start local node → deploy → build Merkle → set root/times → add candidates → vote direct & quiz → see results → check BAL). Add troubleshooting + known limitations and link to docs/architecture.md + SECURITY.md.

Success: README.md is runnable and clear; summary.md updated with “Project complete.”